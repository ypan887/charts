# Default values for pipelines

# Common
initContainerImage: "alpine:3.9"

# Available modes: devmode (enable it for debuging) and production
runMode: production

# Image Registry to pull images from for Pipelines components
# You can override it with your private Artifactory registry
imageRegistry: docker.bintray.io

# For supporting pulling from private registries
imagePullSecrets:

# Existing secret with Pipelines secrets
existingSecret:

# String to partially override pipelines.fullname template (will maintain the release name)
# nameOverride:

# String to fully override pipelines.fullname template
# fullnameOverride:

# Set user/group to run Pipleines components with
securityContext:
  enabled: true
  uid: 1030
  gid: 1030

# The nodes are where the actual builds will run in Kubernetes
nodes:
  # Pipelines Kubernetes Node Quota, Node Pools and Nodes settings
  # It is limited to 3 nodes for the technical preview version!!!
  quotaSize: 3
  poolSize: 3
  replicaCount: 3

  image:
    repository: pipelines-node
    # tag:
    pullPolicy: Always

  resources: {}

  nodeSelector: {}
  tolerations: []
  affinity: {}

  dind:
    image:
      repository: docker
      tag: 18.09.6-dind
      pullPolicy: IfNotPresent

    resources: {}

# Pipelines components
api:
  replicaCount: 1

  image:
    repository: jfrog/pipelines-api
    # tag:
    pullPolicy: IfNotPresent

  # Where the Pipelines Steps images get pulled from
  imageRegistry:
    url: docker.bintray.io

  # For production, the unique token should be generated
  token: f562d4fa-cf5f-4d58-8b9b-91ef949c024f

  # Pipelines ID in Artifactory
  # For production, the unique ID should be generated instead of using 12345
  serviceId: jfpip@12345

  artifactory:
    # The same Artifactory URL as below must be set for Artifactory Custom Base URL as well
    # including the http:// or https:// prefix and adding postfix /artifactory
    # e.g. url: https://artifactory.example.com
    # Custom Base URL: https://myartifactory.example.com/artifactory
    # https://www.jfrog.com/confluence/display/RTF/Configuring+Artifactory
    # https://jfrog.com/knowledge-base/how-can-you-change-custom-url-base-using-rest-api/
    url:
    username: admin
    password: ""

  rabbitMq:
    # Provide internal/external RabbitMQ LB IP or domain or leave it empty, it is only needed if using VMs
    url: ""
    user: admin
    userPassword: ""
    uiUser: adminui
    uiUserPassword: ""

  service:
    # Supported service types: ClusterIP, NodePort and LoadBalancer
    type: ClusterIP
    port: 30000

    annotations:
    # external-dns.alpha.kubernetes.io/hostname:  example.org
    # service.beta.kubernetes.io/aws-load-balancer-backend-protocol: tcp
    # service.beta.kubernetes.io/aws-load-balancer-ssl-cert: arn:aws:acm:us-east-1:XXXXXX:certificate/XXXXXX

    # Set LB static IP
    loadBalancerIP:

    # Whitelist IPs allowed to LoadBalancer type services
    # Example: loadBalancerSourceRanges={82.82.190.51/32,141.141.8.8/32}
    loadBalancerSourceRanges: []

  # External URL, it is ignored if ingress is enabled
  externalUrl:

  ingress:
    enabled: false
    annotations: {}
      # kubernetes.io/ingress.class: nginx
      # kubernetes.io/tls-acme: "true"
    path: /
    hosts:
      - chart-example.local

    tls: []
    #  - secretName: chart-example-tls
    #    hosts:
    #      - chart-example.local

  resources: {}
    # limits:
    #   cpu: 100m
    #   memory: 128Mi
    # requests:
    #   cpu: 100m
    #   memory: 128Mi

  nodeSelector: {}
  tolerations: []
  affinity: {}

www:
  replicaCount: 1

  image:
    repository: jfrog/pipelines-www
    # tag:
    pullPolicy: IfNotPresent

  service:
    # Supported ervice types: ClusterIP, NodePort and LoadBalancer
    type: ClusterIP
    port: 30001

    annotations:
    # external-dns.alpha.kubernetes.io/hostname:  example.org
    # service.beta.kubernetes.io/aws-load-balancer-backend-protocol: tcp
    # service.beta.kubernetes.io/aws-load-balancer-ssl-cert: arn:aws:acm:us-east-1:XXXXXX:certificate/XXXXXX

    # Set LB static IP
    loadBalancerIP:

    # Whitelist IPs allowed to LoadBalancer type services
    # Example: loadBalancerSourceRanges={82.82.190.51/32,141.141.8.8/32}
    loadBalancerSourceRanges: []

  # External URL, it is ignored if ingress is enabled
  externalUrl:

  ingress:
    enabled: false
    annotations: {}
      # kubernetes.io/ingress.class: nginx
      # kubernetes.io/tls-acme: "true"
    path: /
    hosts:
      - chart-example.local

    tls: []
    #  - secretName: chart-example-tls
    #    hosts:
    #      - chart-example.local

  resources: {}
    # limits:
    #   cpu: 100m
    #   memory: 128Mi
    # requests:
    #   cpu: 100m
    #   memory: 128Mi

  nodeSelector: {}
  tolerations: []
  affinity: {}

cron:

  image:
    repository: jfrog/pipelines-micro
    # tag:
    pullPolicy: IfNotPresent

  resources: {}
    # limits:
    #   cpu: 100m
    #   memory: 128Mi
    # requests:
    #   cpu: 100m
    #   memory: 128Mi

  nodeSelector: {}
  tolerations: []
  affinity: {}

nexec:
  replicaCount: 1

  image:
    repository: jfrog/pipelines-micro
    # tag:
    pullPolicy: IfNotPresent

  resources: {}
    # limits:
    #   cpu: 100m
    #   memory: 128Mi
    # requests:
    #   cpu: 100m
    #   memory: 128Mi

  nodeSelector: {}
  tolerations: []
  affinity: {}

pipelineSync:
  replicaCount: 1

  image:
    repository: jfrog/pipelines-micro
    # tag:
    pullPolicy: IfNotPresent

  resources: {}
    # limits:
    #   cpu: 100m
    #   memory: 128Mi
    # requests:
    #   cpu: 100m
    #   memory: 128Mi

  nodeSelector: {}
  tolerations: []
  affinity: {}

runTrigger:
  replicaCount: 1

  image:
    repository: jfrog/pipelines-micro
    # tag:
    pullPolicy: IfNotPresent

  resources: {}
    # limits:
    #   cpu: 100m
    #   memory: 128Mi
    # requests:
    #   cpu: 100m
    #   memory: 128Mi

  nodeSelector: {}
  tolerations: []
  affinity: {}

stepTrigger:

  image:
    repository: jfrog/pipelines-micro
    # tag:
    pullPolicy: IfNotPresent

  resources: {}
    # limits:
    #   cpu: 100m
    #   memory: 128Mi
    # requests:
    #   cpu: 100m
    #   memory: 128Mi

  nodeSelector: {}
  tolerations: []
  affinity: {}

pipelinesInit:
  image:
    repository: pipelines-init
    # tag:
    pullPolicy: Always

# For setting up external services
global:
  # Internal Postgres must be set to false
  postgresql:
    host:
    port: 5432
    database: "pipelinesdb"
    user: "apiuser"
    password: ""


# PostgreSQL 
## https://hub.helm.sh/charts/bitnami/postgresql
## Configuration values for the postgresql dependency
## ref: https://github.com/kubernetes/charts/blob/master/stable/postgresql/README.md
##
postgresql:
  enabled: true

  image:
    tag: "9.6.14-debian-9-r12"

  postgresqlDatabase: "pipelinesdb"
  postgresqlUsername: "apiuser"
  postgresqlPassword: ""

  ## PostgreSQL password using existing secret
  # existingSecret: secret
  ## Mount PostgreSQL secret as a file instead of passing environment variable
  # usePasswordFile: false

  service:
    port: 5432

  persistence:
    enabled: true
    size: 50Gi
    existingClaim:

  master:
    resources: {}
    #  requests:
    #    memory: "1Gi"
    #    cpu: "250m"
    #  limits:
    #    memory: "2Gi"
    #    cpu: "1"
    nodeSelector: {}
    affinity: {}
    tolerations: []

# RabbitMQ - built in non HA RabbitMQ
msg:

  image:
    repository: jfrog/pipelines-msg
    # tag:
    pullPolicy: IfNotPresent

  # Service with LoadBalancer to access RabbitMQ by Node-pool VMs
  serviceLB:

    annotations:
    # Set internal LB for Azure
    #  service.beta.kubernetes.io/azure-load-balancer-internal: "true"
    # Set internal LB for AWS
    #  service.beta.kubernetes.io/aws-load-balancer-internal: 0.0.0.0/0
    # Set internal LB for GCP
      cloud.google.com/load-balancer-type: "Internal"

    # Set LB static IP
    loadBalancerIP:

    # Whitelist IPs allowed to LoadBalancer type services
    # Example: loadBalancerSourceRanges={82.82.190.51/32,141.141.8.8/32}
    loadBalancerSourceRanges: []

  service:
    # Supported ervice types: ClusterIP, NodePort and LoadBalancer
    type: ClusterIP

    annotations:
    # external-dns.alpha.kubernetes.io/hostname:  example.org
    # service.beta.kubernetes.io/aws-load-balancer-backend-protocol: tcp
    # service.beta.kubernetes.io/aws-load-balancer-ssl-cert: arn:aws:acm:us-east-1:XXXXXX:certificate/XXXXXX

    # Whitelist IPs allowed to LoadBalancer type services
    # Example: loadBalancerSourceRanges={82.82.190.51/32,141.141.8.8/32}
    loadBalancerSourceRanges: []

  ingress:
    enabled: false
    annotations: {}
      # kubernetes.io/ingress.class: nginx
      # kubernetes.io/tls-acme: "true"
    path: /
    hosts:
      - chart-example.local

    tls: []
    #  - secretName: chart-example-tls
    #    hosts:
    #      - chart-example.local

  rabbitmqUsername: guest
  rabbitmqPassword: guest
  rabbitmqNodePort: 30200
  rabbitmqAdminNodePort: 30201

  persistence:
    enabled: true
    size: 20Gi

  resources: {}
  #  requests:
  #    memory: "250Mi"
  #    cpu: "100m"
  #  limits:
  #    memory: "550Mi"
  #    cpu: "200m"

  nodeSelector: {}
  affinity: {}
  tolerations: []

# RabbitMQ HA - WIP: Pipelines API needs to support it!
## https://hub.helm.sh/charts/bitnami/rabbitmq
## Configuration values for the rabbitmq dependency
## ref: https://github.com/kubernetes/charts/blob/master/stable/rabbitmq/README.md
##
rabbitmq:
  enabled: false

  replicas: 1

  rabbitmq:
    username: user

    ## RabbitMQ application password
    ## ref: https://github.com/bitnami/bitnami-docker-rabbitmq#environment-variables
    password:
    # existingPasswordSecret: name-of-existing-secret

    ## Erlang cookie to determine whether different nodes are allowed to communicate with each other
    erlangCookie: PIPELINESRABBITMQCLUSTER
    # existingErlangSecret: name-of-existing-secret

    plugins: "rabbitmq_management rabbitmq_peer_discovery_k8s"

  service:
    port: 5672
    managerPort: 15672

  persistence:
    enabled: true
    size: 20Gi

  resources: {}

  affinity: {}

  ingress:
    ## Set to true to enable ingress record generation
    enabled: false

    ## The list of hostnames to be covered with this ingress record.
    ## Most likely this will be just one host, but in the event more hosts are needed, this is an array
    ## hostName: foo.bar.com
    path: /

    ## Set this to true in order to enable TLS on the ingress record
    ## A side effect of this will be that the backend wordpress service will be connected at port 443
    tls: true

    ## If TLS is set to true, you must declare what secret will store the key/certificate for TLS
    tlsSecret: myTlsSecret

    ## Ingress annotations done as key:value pairs
    annotations:
    #  kubernetes.io/ingress.class: nginx
    #  kubernetes.io/tls-acme: true

  # Service with LoadBalancer to access RabbitMQ-HA by Node-pool VMs
  serviceLB:

    annotations:
    # Set internal LB for Azure
    #  service.beta.kubernetes.io/azure-load-balancer-internal: "true"
    # Set internal LB for AWS
    #  service.beta.kubernetes.io/aws-load-balancer-internal: 0.0.0.0/0
    # Set internal LB for GCP
      cloud.google.com/load-balancer-type: "Internal"

    # Set LB static IP
    loadBalancerIP:

    # Whitelist IPs allowed to LoadBalancer type services
    # Example: loadBalancerSourceRanges={82.82.190.51/32,141.141.8.8/32}
    loadBalancerSourceRanges: []

# Redis
## Configuration values for the redis dependency
## ref: https://github.com/kubernetes/charts/blob/master/stable/redis/README.md
##
redis:
  enabled: true

  redisPort: 6379

  cluster:
    enabled: false
    slaveCount: 2

  usePassword: false

  master:
    resources: {}
    #  requests:
    #    memory: 200Mi
    #    cpu: 100m
    #  limits:
    #    memory: 700Mi
    affinity: {}

  slave:
    resources: {}
    #  requests:
    #    memory: 200Mi
    #    cpu: 100m
    #  limits:
    #    memory: 200Mi

# Vault
vault:
  replicaCount: 1

  image:
    repository: vault
    tag: 1.1.3
    pullPolicy: IfNotPresent

  init:
    image:
      repository: pipelines-vault-init
      tag: 0.1.6
      pullPolicy: IfNotPresent

  service:
    # Supported service types: ClusterIP and NodePort
    type: ClusterIP
    port: 30100

  affinity: {}
  nodeSelector: {}
  tolerations: []

  ## Role Based Access
  ## Ref: https://kubernetes.io/docs/admin/authorization/rbac/
  rbac:
    role:
      ## Rules to create. It follows the role specification
      rules:
      - apiGroups:
        - ''
        resources:
        - secrets
        verbs:
        - "*"

#
rbac:
  create: true
